#include "bsp.h"
#include "app.h"
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32H7开发板
//FDCAN驱动代码	   
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2018/6/29
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
//All rights reserved									  
////////////////////////////////////////////////////////////////////////////////// 	
FDCAN_HandleTypeDef FDCAN1_Handler;
FDCAN_RxHeaderTypeDef FDCAN1_RxHeader;
FDCAN_TxHeaderTypeDef FDCAN1_TxHeader;
#define FDCAN1_RX0_INT_ENABLE 1

#define CAN_SET_BOARD_COLLECT 0X00
#define CAN_REQ_SENSOR_STATUE 0X01
#define CAN_REPLY_SENSOR_STATUE 0X81
#define CAN_REQ_BOARD_KIND 0X02
#define CAN_REPLY_BOARD_KIND 0X82
#define CAN_REQ_BOARD_SELFTEST 0X03
#define CAN_REPLY_BOARD_SELFTEST 0X83
#define CAN_REQ_BOARD_FREQ 0X04
#define CAN_REPLY_BOARD_FREQ 0X84
#define CAN_SET_BOARD_FREQ 0X05
//初始化FDCAN1，波特率为500Kbit/S
//配置FDCAN1的时钟源为PLL1Q=200Mhz
//presc:分频值，取值范围1~512
//ntsjw：重新同步跳跃时间单元.范围:1~128
//ntsg1: 取值范围2~256
//ntsg2: 取值范围2~128
//mode:FDCAN_MODE_NORMAL,普通模式;FDCAN_MODE_EXTERNAL_LOOPBACK,回环模式;
//返回值:0,初始化OK;
//    其他,初始化失败; 
void bsp_InitCan1(void)
{
    FDCAN_FilterTypeDef FDCAN1_RXFilter;
        
    //初始化FDCAN1
    HAL_FDCAN_DeInit(&FDCAN1_Handler);                              //先清除以前的设置
    FDCAN1_Handler.Instance=FDCAN1;
    FDCAN1_Handler.Init.FrameFormat=FDCAN_FRAME_CLASSIC;            //传统模式
    FDCAN1_Handler.Init.Mode=FDCAN_FRAME_CLASSIC;                                  //回环测试
    FDCAN1_Handler.Init.AutoRetransmission=DISABLE;                 //关闭自动重传！传统模式下一定要关闭！！！
    FDCAN1_Handler.Init.TransmitPause=DISABLE;                      //关闭传输暂停
    FDCAN1_Handler.Init.ProtocolException=DISABLE;                  //关闭协议异常处理
    FDCAN1_Handler.Init.NominalPrescaler=10;                     //分频系数
    FDCAN1_Handler.Init.NominalSyncJumpWidth=8;                 //重新同步跳跃宽度
    FDCAN1_Handler.Init.NominalTimeSeg1=31;                      //tsg1范围:2~256
    FDCAN1_Handler.Init.NominalTimeSeg2=8;                      //tsg2范围:2~128
    FDCAN1_Handler.Init.MessageRAMOffset=0;                         //信息RAM偏移
    FDCAN1_Handler.Init.StdFiltersNbr=0;                            //标准信息ID滤波器编号
    FDCAN1_Handler.Init.ExtFiltersNbr=0;                            //扩展信息ID滤波器编号
    FDCAN1_Handler.Init.RxFifo0ElmtsNbr=1;                          //接收FIFO0元素编号
    FDCAN1_Handler.Init.RxFifo0ElmtSize=FDCAN_DATA_BYTES_8;         //接收FIFO0元素大小：8字节
    FDCAN1_Handler.Init.RxBuffersNbr=0;                             //接收缓冲编号
    FDCAN1_Handler.Init.TxEventsNbr=0;                              //发送事件编号
    FDCAN1_Handler.Init.TxBuffersNbr=0;                             //发送缓冲编号
    FDCAN1_Handler.Init.TxFifoQueueElmtsNbr=1;                      //发送FIFO序列元素编号
    FDCAN1_Handler.Init.TxFifoQueueMode=FDCAN_TX_FIFO_OPERATION;    //发送FIFO序列模式
    FDCAN1_Handler.Init.TxElmtSize=FDCAN_DATA_BYTES_8;              //发送大小:8字节
    if(HAL_FDCAN_Init(&FDCAN1_Handler)!=HAL_OK) 
		{};           //初始化FDCAN
  
    //配置RX滤波器   
    FDCAN1_RXFilter.IdType=FDCAN_STANDARD_ID;                       //标准ID
    FDCAN1_RXFilter.FilterIndex=0;                                  //滤波器索引                   
    FDCAN1_RXFilter.FilterType=FDCAN_FILTER_MASK;                   //滤波器类型
    FDCAN1_RXFilter.FilterConfig=FDCAN_FILTER_TO_RXFIFO0;           //过滤器0关联到FIFO0  
    FDCAN1_RXFilter.FilterID1=0x0000;                               //32位ID
    FDCAN1_RXFilter.FilterID2=0x0000;                               //如果FDCAN配置为传统模式的话，这里是32位掩码
    if(HAL_FDCAN_ConfigFilter(&FDCAN1_Handler,&FDCAN1_RXFilter)!=HAL_OK) 
		{}	;//滤波器初始化
    HAL_FDCAN_Start(&FDCAN1_Handler);                               //开启FDCAN
    HAL_FDCAN_ActivateNotification(&FDCAN1_Handler,FDCAN_IT_RX_FIFO0_NEW_MESSAGE,0);
    
}

//FDCAN1底层驱动，引脚配置，时钟使能
//HAL_FDCAN_Init()调用
//hsdram:FDCAN1句柄
void HAL_FDCAN_MspInit(FDCAN_HandleTypeDef* hfdcan)
{
    GPIO_InitTypeDef GPIO_Initure;
    RCC_PeriphCLKInitTypeDef FDCAN_PeriphClk;
    
    __HAL_RCC_FDCAN_CLK_ENABLE();                   //使能FDCAN1时钟
    __HAL_RCC_GPIOA_CLK_ENABLE();			        //开启GPIOA时钟
	
    //FDCAN1时钟源配置为PLL1Q
    FDCAN_PeriphClk.PeriphClockSelection=RCC_PERIPHCLK_FDCAN;
    FDCAN_PeriphClk.FdcanClockSelection=RCC_FDCANCLKSOURCE_PLL;
    HAL_RCCEx_PeriphCLKConfig(&FDCAN_PeriphClk);
    
    GPIO_Initure.Pin=GPIO_PIN_11|GPIO_PIN_12;       //PA11,12
    GPIO_Initure.Mode=GPIO_MODE_AF_PP;              //推挽复用
    GPIO_Initure.Pull=GPIO_PULLUP;                  //上拉
    GPIO_Initure.Speed=GPIO_SPEED_FREQ_MEDIUM;      //超高速
    GPIO_Initure.Alternate=GPIO_AF9_FDCAN1;         //复用为CAN1
    HAL_GPIO_Init(GPIOA,&GPIO_Initure);             //初始化
    
   
    HAL_NVIC_SetPriority(FDCAN1_IT0_IRQn,1,2);
    HAL_NVIC_EnableIRQ(FDCAN1_IT0_IRQn);

}

//此函数会被HAL_FDCAN_DeInit调用
//hfdcan:fdcan句柄
void HAL_FDCAN_MspDeInit(FDCAN_HandleTypeDef* hfdcan)
{
    __HAL_RCC_FDCAN_FORCE_RESET();       //复位FDCAN1
    __HAL_RCC_FDCAN_RELEASE_RESET();     //停止复位
    
 
    HAL_NVIC_DisableIRQ(FDCAN1_IT0_IRQn);

}

//can发送一组数据(固定格式:ID为0X12,标准帧,数据帧)	
//len:数据长度(最大为8),可设置为FDCAN_DLC_BYTES_2~FDCAN_DLC_BYTES_8				     
//msg:数据指针,最大为8个字节.
//返回值:0,成功;
//		 其他,失败;
uint8_t id=0;
void can1_SendPacket(uint8_t *_DataBuf, uint8_t _Len)
{		
	FDCAN_TxHeaderTypeDef TxHeader;

	if (_Len > 8)
	{
		return;
	}
	
	/* Prepare Tx Header */
	TxHeader.Identifier = 0x111;
	TxHeader.IdType = FDCAN_STANDARD_ID;
	TxHeader.TxFrameType = FDCAN_DATA_FRAME;
	TxHeader.DataLength = (uint32_t)_Len << 16;
	TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
	TxHeader.BitRateSwitch = FDCAN_BRS_OFF;
	TxHeader.FDFormat = FDCAN_FRAME_CLASSIC;
	TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;
	TxHeader.MessageMarker = 0;
	
    /* Add messages to TX FIFO */
    HAL_FDCAN_AddMessageToTxFifoQ(&FDCAN1_Handler, &TxHeader, _DataBuf);
}

void can1_SendBUF(uint8_t *_DataBuf, uint8_t _Len,uint32_t targetID)
{		
	FDCAN_TxHeaderTypeDef TxHeader;

	if (_Len > 8)
	{
		return;
	}
	
	/* Prepare Tx Header */
	TxHeader.Identifier = targetID;
	TxHeader.IdType = FDCAN_STANDARD_ID;
	TxHeader.TxFrameType = FDCAN_DATA_FRAME;
	TxHeader.DataLength = (uint32_t)_Len << 16;
	TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
	TxHeader.BitRateSwitch = FDCAN_BRS_OFF;
	TxHeader.FDFormat = FDCAN_FRAME_CLASSIC;
	TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;
	TxHeader.MessageMarker = 0;
	
    /* Add messages to TX FIFO */
    HAL_FDCAN_AddMessageToTxFifoQ(&FDCAN1_Handler, &TxHeader, _DataBuf);
}
////can口接收数据查询
////buf:数据缓存区;	 
////返回值:0,无数据被收到;
////		 其他,接收的数据长度;
//u8 FDCAN1_Receive_Msg(u8 *buf)
//{	
//    if(HAL_FDCAN_GetRxMessage(&FDCAN1_Handler,FDCAN_RX_FIFO0,&FDCAN1_RxHeader,buf)!=HAL_OK)return 0;//接收数据
//	return FDCAN1_RxHeader.DataLength>>16;	
//}


//FDCAN1中断服务函数
void FDCAN1_IT0_IRQHandler(void)
{
    HAL_FDCAN_IRQHandler(&FDCAN1_Handler);
}

uint8_t rxdata[8];
uint8_t write_data_canbuf(uint8_t * source,uint16_t length) //这边并没有做can的专门数据存放
{
	can1_SendBUF(source,length,Parameter.can_target_addr);  //
}
uint8_t can_txddata[8];
extern uint8_t board_all_read;
uint8_t AnalyseCan(void)
{
	
	if( ( (Parameter.can_addr+0x100) != FDCAN1_RxHeader.Identifier)
		&& ( 0x104 != FDCAN1_RxHeader.Identifier) ){
		return 0;
	}
	switch(rxdata[0]){
		case CAN_SET_BOARD_COLLECT:
			if(rxdata[1]==0)
			{
				AD7606_StartRecord(config.ADfrequence);
			}else
			{
				AD7606_StopRecord();
			}
			break;
		case CAN_REQ_SENSOR_STATUE:
//			can_txddata[0]=CAN_REPLY_SENSOR_STATUE;
//			can_txddata[1]=Parameter.sensor_satue;
//			can_txddata[1]=Parameter.sensor_satue>>8;
//			write_data_canbuf(can_txddata,8);
			break;
		case CAN_REQ_BOARD_KIND:
//			can_txddata[0]=CAN_REPLY_BOARD_KIND;
//			can_txddata[1]=Parameter.board_kind;
//			write_data_canbuf(can_txddata,8);
			break;
		case CAN_REQ_BOARD_SELFTEST:
//			can_txddata[0]=CAN_REPLY_BOARD_SELFTEST;
//			can_txddata[1]=Parameter.selftest_statue;//暂时未给出该自检的判定方式，后期优化
		if((FDCAN1_RxHeader.Identifier+0x100)==0x100)//判断是第几个板卡发来的信息
		{
			board_all_read |= 1;
		}else if((FDCAN1_RxHeader.Identifier+0x100)==0x110)
		{
			board_all_read |= 2;
		}
		
		board_all_read = 3;//这边将检测的几张卡赋值一下
//			write_data_canbuf(can_txddata,8);
			break;
		case CAN_REQ_BOARD_FREQ:
			can_txddata[0]=CAN_REPLY_BOARD_FREQ;
			can_txddata[1]=config.ADfrequence;
			can_txddata[2]=config.ADfrequence>>8;
			can_txddata[3]=config.freq;
			can_txddata[4]=config.freq>>8;
			write_data_canbuf(can_txddata,8);
			break;
		case CAN_SET_BOARD_FREQ:
			config.ADfrequence=(uint16_t)rxdata[1]|(rxdata[2]<<8);
			config.freq=(uint16_t)rxdata[3]|(rxdata[4]<<8);
			break;
		default:
			break;
	}
}
//FIFO0回调函数
void HAL_FDCAN_RxFifo0Callback(FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo0ITs)
{
    uint8_t i=0;

    if((RxFifo0ITs&FDCAN_IT_RX_FIFO0_NEW_MESSAGE)!=RESET)   //FIFO1新数据中断
    {
        //提取FIFO0中接收到的数据
        HAL_FDCAN_GetRxMessage(hfdcan,FDCAN_RX_FIFO0,&FDCAN1_RxHeader,rxdata);
			
        HAL_FDCAN_ActivateNotification(hfdcan,FDCAN_IT_RX_FIFO0_NEW_MESSAGE,0);
				AnalyseCan();
    }
}

